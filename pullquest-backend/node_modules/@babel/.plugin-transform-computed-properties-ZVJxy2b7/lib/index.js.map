{"version":3,"names":["_core","require","_helperPluginUtils","_template","DefineAccessorHelper","template","expression","ast","_compact","_default","exports","default","declare","api","options","_api$assumption","assertVersion","setComputedProperties","assumption","loose","pushComputedProps","pushComputedPropsLoose","pushComputedPropsSpec","buildDefineAccessor","state","obj","prop","type","kind","key","computed","t","isIdentifier","stringLiteral","name","fn","getValue","helper","availableHelper","addHelper","file","get","id","scope","generateUidIdentifier","push","init","set","cloneNode","callExpression","isObjectProperty","value","isObjectMethod","functionExpression","params","body","generator","async","pushAssign","objId","expressionStatement","assignmentExpression","memberExpression","isLiteral","info","computedProps","initPropExpression","length","CHUNK_LENGTH_CAP","currentChunk","computedPropsChunks","chunk","single","node","toComputedKey","visitor","ObjectExpression","exit","path","parent","hasComputed","properties","initProps","foundComputed","isSpreadElement","generateUidIdentifierBasedOnNode","objectExpression","variableDeclaration","variableDeclarator","replaceWith","replaceWithMultiple"],"sources":["../src/index.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { PluginPass, Scope } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport template from \"@babel/template\";\n\nexport interface Options {\n  loose?: boolean;\n}\n\ntype PropertyInfo = {\n  scope: Scope;\n  objId: t.Identifier;\n  body: t.Statement[];\n  computedProps: t.ObjectMember[];\n  initPropExpression: t.ObjectExpression;\n  state: PluginPass;\n};\n\nif (!process.env.BABEL_8_BREAKING) {\n  // eslint-disable-next-line no-var\n  var DefineAccessorHelper = template.expression.ast`\n    function (type, obj, key, fn) {\n      var desc = { configurable: true, enumerable: true };\n      desc[type] = fn;\n      return Object.defineProperty(obj, key, desc);\n    }\n  `;\n  // @ts-expect-error undocumented _compact node property\n  DefineAccessorHelper._compact = true;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const setComputedProperties =\n    api.assumption(\"setComputedProperties\") ?? options.loose;\n\n  const pushComputedProps = setComputedProperties\n    ? pushComputedPropsLoose\n    : pushComputedPropsSpec;\n\n  function buildDefineAccessor(\n    state: PluginPass,\n    obj: t.Expression,\n    prop: t.ObjectMethod,\n  ) {\n    const type = prop.kind as \"get\" | \"set\";\n    const key =\n      !prop.computed && t.isIdentifier(prop.key)\n        ? t.stringLiteral(prop.key.name)\n        : prop.key;\n    const fn = getValue(prop);\n    if (process.env.BABEL_8_BREAKING) {\n      return t.callExpression(state.addHelper(\"defineAccessor\"), [\n        t.stringLiteral(type),\n        obj,\n        key,\n        fn,\n      ]);\n    } else {\n      let helper: t.Identifier;\n      if (state.availableHelper(\"defineAccessor\")) {\n        helper = state.addHelper(\"defineAccessor\");\n      } else {\n        // Fallback for @babel/helpers <= 7.20.6, manually add helper function\n        const file = state.file;\n        helper = file.get(\"fallbackDefineAccessorHelper\");\n        if (!helper) {\n          const id = file.scope.generateUidIdentifier(\"defineAccessor\");\n          file.scope.push({\n            id,\n            init: DefineAccessorHelper,\n          });\n          file.set(\"fallbackDefineAccessorHelper\", (helper = id));\n        }\n        helper = t.cloneNode(helper);\n      }\n\n      return t.callExpression(helper, [t.stringLiteral(type), obj, key, fn]);\n    }\n  }\n\n  /**\n   * Get value of an object member under object expression.\n   * Returns a function expression if prop is a ObjectMethod.\n   *\n   * @param {t.ObjectMember} prop\n   * @returns t.Expression\n   */\n  function getValue(prop: t.ObjectMember) {\n    if (t.isObjectProperty(prop)) {\n      return prop.value as t.Expression;\n    } else if (t.isObjectMethod(prop)) {\n      return t.functionExpression(\n        null,\n        prop.params,\n        prop.body,\n        prop.generator,\n        prop.async,\n      );\n    }\n  }\n\n  function pushAssign(\n    objId: t.Identifier,\n    prop: t.ObjectMember,\n    body: t.Statement[],\n  ) {\n    body.push(\n      t.expressionStatement(\n        t.assignmentExpression(\n          \"=\",\n          t.memberExpression(\n            t.cloneNode(objId),\n            prop.key,\n            prop.computed || t.isLiteral(prop.key),\n          ),\n          getValue(prop),\n        ),\n      ),\n    );\n  }\n\n  function pushComputedPropsLoose(info: PropertyInfo) {\n    const { computedProps, state, initPropExpression, objId, body } = info;\n\n    for (const prop of computedProps) {\n      if (\n        t.isObjectMethod(prop) &&\n        (prop.kind === \"get\" || prop.kind === \"set\")\n      ) {\n        if (computedProps.length === 1) {\n          return buildDefineAccessor(state, initPropExpression, prop);\n        } else {\n          body.push(\n            t.expressionStatement(\n              buildDefineAccessor(state, t.cloneNode(objId), prop),\n            ),\n          );\n        }\n      } else {\n        pushAssign(t.cloneNode(objId), prop, body);\n      }\n    }\n  }\n\n  function pushComputedPropsSpec(info: PropertyInfo) {\n    const { objId, body, computedProps, state } = info;\n\n    // To prevent too deep AST structures in case of large objects\n    const CHUNK_LENGTH_CAP = 10;\n\n    let currentChunk: t.ObjectMember[] = null;\n    const computedPropsChunks: Array<t.ObjectMember[]> = [];\n    for (const prop of computedProps) {\n      if (!currentChunk || currentChunk.length === CHUNK_LENGTH_CAP) {\n        currentChunk = [];\n        computedPropsChunks.push(currentChunk);\n      }\n      currentChunk.push(prop);\n    }\n\n    for (const chunk of computedPropsChunks) {\n      const single = computedPropsChunks.length === 1;\n      let node: t.Expression = single\n        ? info.initPropExpression\