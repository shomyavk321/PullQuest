{"version":3,"names":["_helperPluginUtils","require","_helperSkipTransparentExpressionWrappers","_core","_default","exports","default","declare","api","options","_api$assumption","_options$allowArrayLi","assertVersion","iterableIsArray","assumption","loose","arrayLikeIsIterable","allowArrayLike","getSpreadLiteral","spread","scope","t","isIdentifier","argument","name","node","binding","getBinding","constant","path","isGenericType","isArrayExpression","template","expression","ast","args","helperName","unshift","hub","addHelper","callExpression","hasHole","elements","includes","hasSpread","nodes","i","length","isSpreadElement","push","_props","arrayExpression","build","props","file","prop","spreadLiteral","visitor","ArrayExpression","first","replaceWith","shift","memberExpression","identifier","CallExpression","arguments","calleePath","skipTransparentExprWrappers","get","isSuper","buildCodeFrameError","contextLiteral","buildUndefinedNode","callee","isMemberExpression","temp","maybeGenerateMemoised","object","assignmentExpression","cloneNode","thisExpression","NewExpression"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { skipTransparentExprWrappers } from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport { types as t, template } from \"@babel/core\";\nimport type { File, NodePath, Scope } from \"@babel/core\";\n\ntype ListElement = t.SpreadElement | t.Expression;\n\nexport interface Options {\n  allowArrayLike?: boolean;\n  loose?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const iterableIsArray = api.assumption(\"iterableIsArray\") ?? options.loose;\n  const arrayLikeIsIterable =\n    options.allowArrayLike ?? api.assumption(\"arrayLikeIsIterable\");\n\n  function getSpreadLiteral(\n    spread: t.SpreadElement,\n    scope: Scope,\n  ): t.Expression {\n    if (\n      iterableIsArray &&\n      !t.isIdentifier(spread.argument, { name: \"arguments\" })\n    ) {\n      return spread.argument;\n    } else {\n      const node = spread.argument;\n\n      if (t.isIdentifier(node)) {\n        const binding = scope.getBinding(node.name);\n        if (binding?.constant && binding.path.isGenericType(\"Array\")) {\n          return node;\n        }\n      }\n\n      if (t.isArrayExpression(node)) {\n        return node;\n      }\n\n      if (t.isIdentifier(node, { name: \"arguments\" })) {\n        return template.expression.ast`\n          Array.prototype.slice.call(${node})\n        `;\n      }\n\n      const args = [node];\n      let helperName = \"toConsumableArray\";\n\n      if (arrayLikeIsIterable) {\n        args.unshift(scope.path.hub.addHelper(helperName));\n        helperName = \"maybeArrayLike\";\n      }\n\n      return t.callExpression(scope.path.hub.addHelper(helperName), args);\n    }\n  }\n\n  function hasHole(spread: t.ArrayExpression): boolean {\n    return spread.elements.includes(null);\n  }\n\n  function hasSpread(nodes: Array<t.Node>): boolean {\n    for (let i = 0; i < nodes.length; i++) {\n      if (t.isSpreadElement(nodes[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function push(_props: Array<ListElement>, nodes: Array<t.Expression>) {\n    if (!_props.length) return _props;\n    nodes.push(t.arrayExpression(_props));\n    return [];\n  }\n\n  function build(\n    props: Array<ListElement>,\n    scope: Scope,\n    file: File,\n  ): t.Expression[] {\n    const nodes: Array<t.Expression> = [];\n    let _props: Array<ListElement> = [];\n\n    for (const prop of props) {\n      if (t.isSpreadElement(prop)) {\n        _props = push(_props, nodes);\n        let spreadLiteral = getSpreadLiteral(prop, scope);\n\n        if (t.isArrayExpression(spreadLiteral) && hasHole(spreadLiteral)) {\n          spreadLiteral = t.callExpression(\n            file.addHelper(\n              process.env.BABEL_8_BREAKING\n                ? \"arrayLikeToArray\"\n                : \"arrayWithoutHoles\",\n            ),\n            [spreadLiteral],\n          );\n        }\n\n        nodes.push(spreadLiteral);\n      } else {\n        _props.push(prop);\n      }\n    }\n\n    push(_props, nodes);\n\n    return nodes;\n  }\n\n  return {\n    name: \"transform-spread\",\n\n    visitor: {\n      ArrayExpression(path): void {\n        const { node, scope } = path;\n        const elements = node.elements;\n        if (!hasSpread(elements)) return;\n\n        const nodes = build(elements, scope, this.file);\n        let first = nodes[0];\n\n        // If there is only one element in the ArrayExpression and\n        // the element was transformed (Array.prototype.slice.call or toConsumableArray)\n        // we know that the transformed code already takes care of cloning the array.\n        // So we can simply return that element.\n        if (\n          nodes.length === 1 &&\n          first !== (elements[0] as t.SpreadElement).argument\n        ) {\n          path.replaceWith(first);\n          return;\n        }\n\n        // If the first element is a ArrayExpression we can directly call\n        // concat on it.\n        // `[..].concat(..)`\n        // If not then we have to use `[].concat(arr)` and not `arr.concat`\n        // because `arr` could be extended/modified (e.g. Immutable) and we do not know exactly\n        // what concat would produce.\n        if (!t.isArrayExpression(first)) {\n          first = t.arrayExpression([]);\n        } else {\n          nodes.shift();\n        }\n\n        path.replaceWith(\n          t.callExpression(\n            t.memberExpression(first, t.identifier(\"concat\")),\n            nodes,\n          ),\n        );\n      },\n      CallExpression(path): void {\n        const { node, scope } = path;\n\n        const args = node.arguments as Array<ListElement>;\n        if (!hasSpread(args)) return;\n        const calleePath = skipTransparentExprWrappers(\n          path.get(\"callee\") as NodePath<t.Expression>,\n        );\n        if (calleePath.isSuper()) {\n          // NOTE: spread and classes have almost the same compat dat