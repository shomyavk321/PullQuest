{"version":3,"file":"index.js","sources":["../src/normalize-options.ts","../src/plugin-rewrite-ts-imports.ts","../src/index.ts"],"sourcesContent":["import { OptionValidator } from \"@babel/helper-validator-option\";\nconst v = new OptionValidator(\"@babel/preset-typescript\");\n\nexport interface Options {\n  ignoreExtensions?: boolean;\n  allowDeclareFields?: boolean;\n  allowNamespaces?: boolean;\n  disallowAmbiguousJSXLike?: boolean;\n  jsxPragma?: string;\n  jsxPragmaFrag?: string;\n  onlyRemoveTypeImports?: boolean;\n  optimizeConstEnums?: boolean;\n  rewriteImportExtensions?: boolean;\n\n  // TODO: Remove in Babel 8\n  allExtensions?: boolean;\n  isTSX?: boolean;\n}\n\nexport default function normalizeOptions(options: Options = {}) {\n  let { allowNamespaces = true, jsxPragma, onlyRemoveTypeImports } = options;\n\n  const TopLevelOptions: {\n    [Key in keyof Omit<Options, \"allowDeclareFields\">]-?: Key;\n  } = {\n    ignoreExtensions: \"ignoreExtensions\",\n    allowNamespaces: \"allowNamespaces\",\n    disallowAmbiguousJSXLike: \"disallowAmbiguousJSXLike\",\n    jsxPragma: \"jsxPragma\",\n    jsxPragmaFrag: \"jsxPragmaFrag\",\n    onlyRemoveTypeImports: \"onlyRemoveTypeImports\",\n    optimizeConstEnums: \"optimizeConstEnums\",\n    rewriteImportExtensions: \"rewriteImportExtensions\",\n\n    // TODO: Remove in Babel 8\n    allExtensions: \"allExtensions\",\n    isTSX: \"isTSX\",\n  };\n\n  if (process.env.BABEL_8_BREAKING) {\n    v.invariant(\n      !(\"allowDeclareFields\" in options),\n      \"The .allowDeclareFields option has been removed and it's now always enabled. Please remove it from your config.\",\n    );\n    v.invariant(\n      !(\"allExtensions\" in options) && !(\"isTSX\" in options),\n      \"The .allExtensions and .isTSX options have been removed.\\n\" +\n        \"If you want to disable JSX detection based on file extensions, \" +\n        \"you can set the .ignoreExtensions option to true.\\n\" +\n        \"If you want to force JSX parsing, you can enable the \" +\n        \"@babel/plugin-syntax-jsx plugin.\",\n    );\n\n    v.validateTopLevelOptions(options, TopLevelOptions);\n    allowNamespaces = v.validateBooleanOption(\n      TopLevelOptions.allowNamespaces,\n      options.allowNamespaces,\n      true,\n    );\n    jsxPragma = v.validateStringOption(\n      TopLevelOptions.jsxPragma,\n      options.jsxPragma,\n      \"React\",\n    );\n    onlyRemoveTypeImports = v.validateBooleanOption(\n      TopLevelOptions.onlyRemoveTypeImports,\n      options.onlyRemoveTypeImports,\n      true,\n    );\n  }\n\n  const jsxPragmaFrag = v.validateStringOption(\n    TopLevelOptions.jsxPragmaFrag,\n    options.jsxPragmaFrag,\n    \"React.Fragment\",\n  );\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // eslint-disable-next-line no-var\n    var allExtensions = v.validateBooleanOption(\n      TopLevelOptions.allExtensions,\n      options.allExtensions,\n      false,\n    );\n\n    // eslint-disable-next-line no-var\n    var isTSX = v.validateBooleanOption(\n      TopLevelOptions.isTSX,\n      options.isTSX,\n      false,\n    );\n    if (isTSX) {\n      v.invariant(allExtensions, \"isTSX:true requires allExtensions:true\");\n    }\n  }\n\n  const ignoreExtensions = v.validateBooleanOption(\n    TopLevelOptions.ignoreExtensions,\n    options.ignoreExtensions,\n    false,\n  );\n\n  const disallowAmbiguousJSXLike = v.validateBooleanOption(\n    TopLevelOptions.disallowAmbiguousJSXLike,\n    options.disallowAmbiguousJSXLike,\n    false,\n  );\n  if (disallowAmbiguousJSXLike) {\n    if (process.env.BABEL_8_BREAKING) {\n      v.invariant(\n        ignoreExtensions,\n        \"disallowAmbiguousJSXLike:true requires ignoreExtensions:true\",\n      );\n    } else {\n      v.invariant(\n        allExtensions,\n        \"disallowAmbiguousJSXLike:true requires allExtensions:true\",\n      );\n    }\n  }\n\n  const optimizeConstEnums = v.validateBooleanOption(\n    TopLevelOptions.optimizeConstEnums,\n    options.optimizeConstEnums,\n    false,\n  );\n\n  const rewriteImportExtensions = v.validateBooleanOption(\n    TopLevelOptions.rewriteImportExtensions,\n    options.rewriteImportExtensions,\n    false,\n  );\n\n  const normalized: Options = {\n    ignoreExtensions,\n    allowNamespaces,\n    disallowAmbiguousJSXLike,\n    jsxPragma,\n    jsxPragmaFrag,\n    onlyRemoveTypeImports,\n    optimizeConstEnums,\n    rewriteImportExtensions,\n  };\n  if (!process.env.BABEL_8_BREAKING) {\n    normalized.allExtensions = allExtensions;\n    normalized.isTSX = isTSX;\n  }\n  return normalized;\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport type { types as t, NodePath, PluginPass } from \"@babel/core\";\n\nexport default declare(function ({ types: t, template }) {\n  function maybeReplace(\n    source: t.ArgumentPlaceholder | t.Expression,\n    path: NodePath,\n    state: PluginPass,\n  ) {\n    if (!source) return;\n    // todo: if we want to support `preserveJsx`, we can register a global flag via file.set from transform-react-jsx, and read it here.\n    const preserveJsx = false;\n    if (t.isStringLiteral(source)) {\n      if (/^\\.\\.?\\//.test(source.value)) {\n        // @see packages/babel-helpers/src/helpers/tsRewriteRelativeImportExtensions.ts\n        source.value = source.value.replace(\n          /\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+)?)\\.([cm]?)ts$/i,\n          function (m, tsx, d, ext, cm) {\n            return tsx\n              ? preserveJsx\n                ? \".jsx\"\n                : \".js\"\n              : d && (!ext || !cm)\n                ? m\n                : d + ext + \".\" + cm.toLowerCase() + \"js\";\n          },\n        );\n      }\n      return;\n    }\n\n    if (\n      process.env.BABEL_8_BREAKING ||\n      state.availableHelper(\"tsRewriteRelativeImportExtensions\")\n    ) {\n      path.replaceWith(\n        t.callExpression(\n          state.addHelper(\"tsRewriteRelativeImportExtensions\"),\n          preserveJsx ? [source, t.booleanLiteral(true)] : [source],\n        ),\n      );\n    } else {\n      path.replaceWith(\n        template.expression\n          .ast`(${source}