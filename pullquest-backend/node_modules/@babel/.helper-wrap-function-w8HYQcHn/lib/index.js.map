{"version":3,"names":["_template","require","_t","blockStatement","callExpression","functionExpression","isAssignmentPattern","isFunctionDeclaration","isRestElement","returnStatement","isCallExpression","memberExpression","identifier","thisExpression","isPattern","buildAnonymousExpressionWrapper","template","expression","buildNamedExpressionWrapper","buildDeclarationWrapper","statements","classOrObjectMethod","path","callId","ignoreFunctionLength","node","body","params","shoudlForwardParams","some","p","param","push","scope","generateUidIdentifier","container","get","unwrapFunctionEnvironment","async","generator","plainFunction","inPath","noNewArrows","hadName","functionId","nodeParams","isArrowFunctionExpression","_path$arrowFunctionTo","arrowFunctionToExpression","isDeclaration","built","id","type","wrapperArgs","NAME","REF","name","FUNCTION","PARAMS","replaceWith","insertAfter","length","wrapFunction","isMethod","_path","_path$ensureFunctionN","ensureFunctionName","NodePath","prototype"],"sources":["../src/index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\nimport template from \"@babel/template\";\nimport {\n  blockStatement,\n  callExpression,\n  functionExpression,\n  isAssignmentPattern,\n  isFunctionDeclaration,\n  isRestElement,\n  returnStatement,\n  isCallExpression,\n  memberExpression,\n  identifier,\n  thisExpression,\n  isPattern,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\ntype ExpressionWrapperBuilder<ExtraBody extends t.Node[]> = (\n  replacements?: Parameters<ReturnType<typeof template.expression>>[0],\n) => t.CallExpression & {\n  callee: t.FunctionExpression & {\n    body: {\n      body: [\n        t.VariableDeclaration & {\n          declarations: [\n            { init: t.FunctionExpression | t.ArrowFunctionExpression },\n          ];\n        },\n        ...ExtraBody,\n      ];\n    };\n  };\n};\n\nconst buildAnonymousExpressionWrapper = template.expression(`\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n`) as ExpressionWrapperBuilder<\n  [t.ReturnStatement & { argument: t.FunctionExpression }]\n>;\n\nconst buildNamedExpressionWrapper = template.expression(`\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n`) as ExpressionWrapperBuilder<\n  [t.FunctionDeclaration, t.ReturnStatement & { argument: t.Identifier }]\n>;\n\nconst buildDeclarationWrapper = template.statements(`\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n`);\n\nfunction classOrObjectMethod(\n  path: NodePath<t.ClassMethod | t.ClassPrivateMethod | t.ObjectMethod>,\n  callId: t.Expression,\n  ignoreFunctionLength: boolean,\n) {\n  const node = path.node;\n  const body = node.body;\n\n  let params: Array<t.Identifier | t.Pattern | t.RestElement> = [];\n\n  // Errors thrown during argument evaluation must reject the resulting promise\n  const shoudlForwardParams = node.params.some(p => isPattern(p));\n\n  if (shoudlForwardParams) {\n    params = node.params as typeof params;\n    node.params = [];\n    if (!ignoreFunctionLength) {\n      for (const param of params) {\n        if (isAssignmentPattern(param) || isRestElement(param)) {\n          break;\n        }\n        node.params.push(path.scope.generateUidIdentifier(\"x\"));\n      }\n    }\n  }\n\n  const container = functionExpression(\n    null,\n    params,\n    blockStatement(body.body),\n    true,\n  );\n\n  if (shoudlForwardParams) {\n    // return asyncToGenerator(function*() { ... }).apply(this, arguments);\n    body.body = [\n      returnStatement(\n        callExpression(\n          memberExpression(\n            callExpression(callId, [container]),\n            identifier(\"apply\"),\n          ),\n          [thisExpression(), identifier(\"arguments\")],\n        ),\n      ),\n    ];\n\n    (\n      path.get(\"body.body.0.argument.callee.object.arguments.0\") as NodePath\n    ).unwrapFunctionEnvironment();\n  } else {\n    // return asyncToGenerator(function*() { ... })();\n    body.body = [\n      returnStatement(callExpression(callExpression(callId, [container]), [])),\n    ];\n\n    // Unwrap the wrapper IIFE's environment so super and this and such still work.\n    (\n      path.get(\"body.body.0.argument.callee.arguments.0\") as NodePath\n    ).unwrapFunctionEnvironment();\n  }\n\n  // Regardless of whether or not the wrapped function is a an async method\n  // or generator the outer function should not be\n  node.async = false;\n  node.generator = false;\n}\n\nfunction plainFunction(\n  inPath: NodePath<Exclude<t.Function, t.Method>>,\n  callId: t.Expression,\n  noNewArrows: boolean,\n  ignoreFunctionLength: boolean,\n  hadName: boolean,\n) {\n  let path: NodePath<\n    | t.FunctionDeclaration\n    | t.FunctionExpression\n    | t.CallExpression\n    | t.ArrowFunctionExpression\n  > = inPath;\n  let node;\n  let functionId = null;\n  const nodeParams = inPath.node.params;\n\n  if (path.isArrowFunctionExpression()) {\n    if (process.env.BABEL_8_BREAKING) {\n      path = path.arrowFunctionToExpression({ noNewArrows });\n    } else {\n      // arrowFunctionToExpression returns undefined in @babel/traverse < 7.18.10\n      path = path.arrowFunctionToExpression({ noNewArrows }) ?? path;\n    }\n    node = path.node as\n      | t.FunctionDeclaration\n      | t.FunctionExpression\n      | t.CallExpression;\n  } else {\n    node = path.node;\n  }\n\n  const isDeclaration = isFunctionDeclaration(node);\n\n  let built = node;\n  if (!isCallExpression(node)) {\n    functionId = node.id;\n    node.id = null;\n    node.type = \"FunctionExpression\";\n    built = callExpression(callId, [\n      node as Exclude<typeof node, t.FunctionDeclaration>,\n    ]);\n  }\n\n  const params: t.Identifier[] = [];\n  for (const param of nodeParams) {\n    if (isAssignmentPattern(param) || isRestElement(param)) {\n      break;\n    }\n    params.push(path.scope.generateUidIdentifier(\"x\"));\n  }\n\n  const wrapperArgs = {\n    NAME: functionId || null,\n    // TODO: Use `functionId` rather than `hadName` for the condition\n    REF: path.scope.generateUidIdentifier(hadName ? functionId.name : \"ref\"),\n    FUNCTION: built,\n    PARAMS: params,\n  };\n\n  if (isDeclaration) {\n    const container = buildDeclarationWrapper(wrapperArgs);\n    path.replaceWith(container[0]);\n    path.insertAfter(container[1]);\n  } else {\n    let container;\n\n    if (hadName) {\n      container = buildNamedExpressionWrapper(wrapperArgs);\n    } else {\n      container = buildAnonymousExpressionWrapper(wrapperArgs);\n    }\n\n    if (functionId || (!ignoreFunctionLength && params.length)) {\n      path.replaceWith(container);\n    } else {\n      // we can omit this wrapper as the conditions it protects for do not apply\n      path.replaceWith(built);\n    }\n  }\n}\n\nexport default function wrapFunction(\n  path: NodePath<t.Function>,\n  callId: t.Expression,\n  // TODO(Babel 8): Consider defaulting to false for spec compliance\n  noNewArrows: boolean = true,\n  ignoreFunctionLength: boolean = false,\n) {\n  if (path.isMethod()) {\n    classOrObjectMethod(path, callId, ignoreFunctionLength);\n  } else {\n    const hadName = \"id\" in path.node && !!path.node.id;\n    if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n      // polyfill when being run by an older Babel version\n      path.ensureFunctionName ??=\n        // eslint-disable-next-line no-restricted-globa